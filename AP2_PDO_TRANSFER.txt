
	SUBROUTINE	DH$_PDO_TO_COIL
	1		(
	1		PDO
	1		)

	IMPLICIT 	NONE

C	Include
C	-----------------------------------------------------------------------
	INCLUDE 	'DH$INC:DH.INC'
	INCLUDE		'CAP$INC:CAP_PDO.INC'
	INCLUDE		'CAP$INC:CAP_PDI.INC'
	INCLUDE		'HPS$DB$INC:PCM0020M.INC'
	INCLUDE		'HPS$DB$INC:PCM0100M.INC'
	INCLUDE  	'HPS$DB$INC:PCM0030M.INC'
	INCLUDE     'CPS$INC:ORD.INC'
C	argument
C	-----------------------------------------------------------------------
	RECORD	/CAP_PDO/	PDO

C	Record
C	-----------------------------------------------------------------------
	RECORD	/PCM0020M/	COIL
	POINTER		( COIL_PNT , COIL )

	RECORD	/PCM0100M/	ORDB
	POINTER		( ORDB_PNT , ORDB )

	RECORD	/CAP_PDI/	PDI
	POINTER		( PDI_PNT , PDI)

	RECORD  /ORDB011M_DEF/  L4ORD

	RECORD /PCM0030M/ COILH
C	variable
C	-----------------------------------------------------------------------
	INTEGER*2	CUT
	CHARACTER*14	VMS_DATE
	CHARACTER*1	DIVIDE_YN
	BYTE		NO_OF_COILS
	CHARACTER*1	MILL_CODE
	INTEGER*2	I
	INTEGER*4	STATUS,Z_IDX
	CHARACTER*7	S_DATE

	INTEGER*4	TOTAL_REDUCTION
	CHARACTER*1	RESTRICT_APN,FLAG
	
	CHARACTER*3     NEXT_STATION,CURR_STATION,PREV_STATION
	REAL*4          MOTHER_WEIGHT
	INTEGER*4       PCM_WEIGHT
	CHARACTER*2     IC_CODE
	CHARACTER*11    BROTHER_COIL_NO
	INTEGER*4       SQLCOD
	INTEGER*4       SQLCODE
	CHARACTER*20    BCODE,Z_CODE,ACTL_PCODE
	CHARACTER*10	CCODE
	INTEGER*4       L,M,N,CLEN
	INTEGER*4   CCC,PPP

C	function
C	-----------------------------------------------------------------------
	INTEGER*4   PCM0100M_R
	INTEGER*4	ORDB011M_R
	INTEGER*4	PCM0020M_R
	INTEGER*4	PCM0023W_R
	INTEGER*4	COIL_MOVE
	INTEGER*4	COIL_RECALL
	INTEGER*4	COIL_CUT
	INTEGER*4	OUTER_DIAMETER
	INTEGER*4	GR_C8DATE_TO_BIN
	INTEGER*4	CPS_RESTRICT_APN
	INTEGER*4   NORDB011M_R
C	INTEGER*4   CAP_PDI_R

C	-----------------------------------------------------------------------
C					CODE
C	-----------------------------------------------------------------------
	IF (PDO.TRANSFER .EQ. 'Y') THEN
	   CALL DH_NOTICE('轉換碼已經是 Y')
	   RETURN
	ENDIF

        CALL CPS_PCMB020M_SEARCH_NEW
	1  ( PDO.COIL_NO,
	1    PREV_STATION,
	1    CURR_STATION,
	1    NEXT_STATION,
	1    PCM_WEIGHT,
	1    IC_CODE,
	1    SQLCOD)

	IF  ( SQLCOD .EQ. 0 ) THEN
	    IF ((CURR_STATION .EQ. 'CAP' ) .AND. 
	1	((IC_CODE .EQ. '32' ) .OR. (IC_CODE .EQ. '46'))) THEN
	         MOTHER_WEIGHT = PCM_WEIGHT ! use no split weight for running_mode of input weight
	    ELSE
	        CALL DH_NOTICE(
	1        '本製程不為CAP或IC_CODE<>32/46:'
	1	//CURR_STATION//'-'//IC_CODE//' 不可結轉PDO')
		RETURN
	    ENDIF
	ELSE
C       --STEP2.鋼捲編號縮減一碼再搜尋--
	   CALL GR_ALLTRIM ( PDO.COIL_NO , CUT )
	   IF (CUT .LE. 8) THEN
	        CALL DH_NOTICE('COIL_NO 減一碼 找不到本製程,不可結轉PDO')
		RETURN 
	   ELSE
	      CALL DH_INTERNAL_MSG
	1	(' COIL_NO 減一碼 ='//PDO.COIL_NO(1:CUT-1)//'搜尋中...!',2)

	        CALL CPS_PCMB020M_SEARCH_NEW
	1  	( PDO.COIL_NO(1:CUT-1)//'   ',
	1    	  PREV_STATION,
	1    	  CURR_STATION,
	1         NEXT_STATION,
	1         PCM_WEIGHT,
	1         IC_CODE,
	1         SQLCOD)
		IF ( SQLCOD .EQ. 0 ) THEN
	            IF ((CURR_STATION .EQ. 'CAP' ) .AND. 
	1	       ((IC_CODE .EQ. '32' ) .OR. (IC_CODE .EQ. '46'))) THEN
	               CALL DH_INTERNAL_MSG
	1	       (' COIL_NO 減一碼 找到本製程=CAP且狀態=32/46...!',2)
		ELSE
	              CALL DH_NOTICE
	1               ('COIL_NO 減一碼,本製程不為CAP或IC_CODE<>32/46:'
	1		//CURR_STATION//'-'//IC_CODE//' 不可結轉')
		      RETURN
		    ENDIF
		ELSE  ! 判斷同一代兄弟鋼捲是否存在且上製程為CAP
	           CALL DH_INTERNAL_MSG
	1	   (' 判斷同一代兄弟鋼捲是否存在且上製程為CAP且狀態=32/46...!',2)
        	   CALL CPS_PCMB020M_BROTHER
	1  	      ( PDO.COIL_NO,
	1	      'CAP',		! CHECK LINE
	1  	      BROTHER_COIL_NO,
	1	      SQLCOD)
		   IF ( SQLCOD .EQ. 0 ) THEN
	           CALL DH_INTERNAL_MSG
	1	   (' 找到同一代兄弟鋼捲='//BROTHER_COIL_NO
	1	      //'其上製程為CAP 開始結轉!',2 )
		   ELSE
	              CALL DH_NOTICE
	1               ('找不到同一代兄弟鋼捲'//BROTHER_COIL_NO//',且上製程為CAP, 不可結轉!')
		      RETURN
		   ENDIF
		ENDIF
	    ENDIF
	ENDIF
C	CALL DH_WORKING_OUTPUT(1)

	

CD	假設沒有分切
	DIVIDE_YN = 'N'
C	modi by yu68187 use pdo directly
	IF ( PDO.COIL_NO .NE. PDO.MOTHER_COIL_NO ) DIVIDE_YN = 'Y'

	CALL LIB$GET_VM ( SIZEOF(COIL) , COIL_PNT , )
	CALL LIB$GET_VM ( SIZEOF(ORDB) , ORDB_PNT , )

	CUT = 0
	COIL.COIL_ID = PDO.COIL_NO
	DH_ITEM_LIST.STATUS = PCM0020M_R ( COIL )
	
	
CD	if 鋼捲編號不在鋼捲資料檔中
	IF (DH_ITEM_LIST.STATUS .NE. 0) THEN

C	   DIVIDE_YN = 'Y'				! 被分切

CD	   if 鋼捲編號超過8碼=>檢查是否為被分切之鋼捲
	   CALL GR_ALLTRIM ( COIL.COIL_ID , CUT )
	   IF (CUT .GT. 8) THEN
	      COIL.COIL_ID(CUT:CUT) = ' '
	      DH_ITEM_LIST.STATUS = PCM0020M_R ( COIL )

CD            分切時,壓下率需取母鋼捲 89/07/24
              IF ( (TOTAL_REDUCTION .LE. 0) .AND.
	1          (COIL.TOTAL_REDUCTION .LE. 100) ) THEN
                TOTAL_REDUCTION = COIL.TOTAL_REDUCTION
              END IF 

	      IF (DH_ITEM_LIST.STATUS .EQ. 0) THEN
		 DH_ITEM_LIST.STATUS = COIL_CUT ( COIL.COIL_ID )
		 IF (DH_ITEM_LIST.STATUS .NE. 0) THEN
		    CALL DH_NOTICE ('分切動作失敗')
		    RETURN
		 ENDIF
	      ENDIF

C       ---53.廠區--
		COIL.FACTORY = 'A'

	      DH_ITEM_LIST.STATUS = COIL_RECALL
	1			(
	1			COIL.COIL_ID,			! old coil-id
	1			PDO.COIL_NO,			! new coil-id
	1			COIL.FACTORY,
	1			COIL.TOTAL_REDUCTION
	1			)
	      IF (DH_ITEM_LIST.STATUS .NE. 0) THEN
			WRITE (6,*) '不在分切暫存檔',DH_ITEM_LIST.STATUS
				CALL LIB$FREE_VM ( SIZEOF(COIL) , COIL_PNT , )
			RETURN
	      ENDIF
	      CALL DH_NOTICE ('COIL_RECALL called ! check...')

	   ELSE
	      CALL DH_INTERNAL_MSG(COIL.COIL_ID//'不在鋼捲資料檔',2)
	      CALL LIB$FREE_VM ( SIZEOF(COIL) , COIL_PNT , )
	      RETURN
	   ENDIF
CD	   再確定PDO之鋼捲編號是否已存在於鋼捲資料檔
	   COIL.COIL_ID = PDO.COIL_NO
	   DH_ITEM_LIST.STATUS = PCM0020M_R ( COIL )
CD	   if 鋼捲編號不在鋼捲資料檔中
	   IF (DH_ITEM_LIST.STATUS .NE. 0) THEN
	      CALL DH_INTERNAL_MSG('不在鋼捲資料檔中',3)
	      CALL LIB$FREE_VM ( SIZEOF(COIL) , COIL_PNT , )
	      RETURN
	   ENDIF
	ENDIF

	
CD	20200130 生計部小馬需求 BY林育維
	  ORDB.ORDER_NO   = COIL.CB_FIRST_ORD_NO(1:7) !改取PCMB100M
	  ORDB.ORDER_ITEM = COIL.CB_FIRST_ORD_NO(8:9)
	  DH_ITEM_LIST.STATUS = PCM0100M_R ( ORDB )
	  L4ORD.ORDER_NO   = COIL.CB_FIRST_ORD_NO(1:7)
	  L4ORD.ORDER_ITEM = COIL.CB_FIRST_ORD_NO(8:9)
	  DH_ITEM_LIST.STATUS = NORDB011M_R ( L4ORD )
C	  PDI.COIL_NO = PDO.MOTHER_COIL_NO
C	  CALL CAP_PDI_R ( PDI )
	  


	IF (COIL.CURR_STATION .NE. 'CAP') THEN
	   IF ((COIL.PREV_STATION .EQ. 'CAP') .AND.
	1      (COIL.IC_CODE .EQ. '32')) THEN
	      CALL DH_NOTICE('Msg 77: 本製程不是 CAP ,'//
	1		  '請至鋼捲資料檔更改製程路徑')
	   ELSE IF ((COIL.PREV_STATION .EQ. 'CAP') .AND.
	1           (INDEX('46.13',COIL.IC_CODE) .GT. 0)) THEN
	      CALL DH_NOTICE('Msg 88: 鋼捲已排入下製程 ,'//
	1		  '無法更改鋼捲資料檔')
	   ELSE IF (COIL.PREV_STATION .NE. 'CAP') THEN
	      CALL DH_NOTICE('Msg 99: 鋼捲已於下製程產出 ,'//
	1		  '無法更改鋼捲資料檔')
	   ENDIF

CD	   返回
	   RETURN
	ENDIF
 
C       ---1.鋼捲編號---
C	不變
C       ---2.鋼胚編號---
C	不變
C       ---3.鋼種編號---
C	不變
C       ---4.鋼種類別---
C	不變
C       ---5.鋼種系列---
C	不變
C	---6.鋼捲厚度--- 
	IF (PDO.ACTUAL_THICKNESS .GT. 0) THEN
	   COIL.COIL_THICK = PDO.ACTUAL_THICKNESS
	ENDIF
C   ---7.鋼捲寬度---
	IF (PDO.ACTUAL_WIDTH .GT. 0) THEN
	   COIL.COIL_WIDTH = PDO.ACTUAL_WIDTH
	ENDIF
C   ---8.鋼捲重量---
	IF (PDO.ACTUAL_WEIGHT .GT. 0) THEN
	   COIL.COIL_WT = PDO.ACTUAL_WEIGHT
	ELSE IF (PDO.THEO_WEIGHT .GT. 0) THEN
	   COIL.COIL_WT = PDO.THEO_WEIGHT
	ENDIF
C   ---9.鋼捲內徑---
	COIL.INNER_DIAM = 610
C 	---10.鋼捲外徑---
C	計算外徑
	COIL.OUTER_DIAM = OUTER_DIAMETER
	1		(
	1		COIL.STEEL_GRADE,
	1		COIL.COIL_WT,
	1		COIL.COIL_WIDTH,
	1		610
	1		)
C   ---11.品管判級---
	COIL.CLASS_CODE = PDO.CLASS_CODE
C   ---12.目前儲位---
	COIL.STORAGE = ' '

	ACTL_PCODE = ''
C 	---15.實際製程編號---
C	15.1
	IF (PDO.GRINDING_PARM .LE. ' ') THEN
	  IF (INDEX('RF',PDO.CLASS_CODE) .GT. 0) THEN
	    COIL.ACTL_PCODE(COIL.CURR_PROC_IDX+1:) = 'Q'//
	1               COIL.ACTL_PCODE(COIL.CURR_PROC_IDX+1:)
	  ELSEIF (PDO.CLASS_CODE .EQ. 'S') THEN
	    COIL.ACTL_PCODE(COIL.CURR_PROC_IDX+2:20) = ' '
	    COIL.ACTL_PCODE(COIL.CURR_PROC_IDX+1:) = '$'
	  ENDIF
C 	15.2
	ELSEIF (PDO.GRINDING_PARM .NE. ' ') THEN
	  IF ((INDEX('12',PDO.GRINDING_PARM) .GT. 0) .AND.
	1     (INDEX('1AB23DC',COIL.CLASS_CODE) .GT. 0)) THEN
	    I = COIL.CURR_PROC_IDX
	    COIL.ACTL_PCODE(I+1:) = 'VMP'// COIL.ACTL_PCODE(I+1:)
 
	  ELSEIF ((INDEX('3',PDO.GRINDING_PARM) .GT. 0)  .AND.
	1         (INDEX('1AB23DC',COIL.CLASS_CODE) .GT. 0)) THEN
	    I = COIL.CURR_PROC_IDX
	    COIL.ACTL_PCODE(I+1:) = 'WMP'// COIL.ACTL_PCODE(I+1:)

	  ELSEIF ((INDEX('45',PDO.GRINDING_PARM) .GT. 0)  .AND.
	1         (INDEX('1AB23DC',COIL.CLASS_CODE) .GT. 0)) THEN
	    I = COIL.CURR_PROC_IDX
	    COIL.ACTL_PCODE(I+1:) = 'NVMP'// COIL.ACTL_PCODE(I+1:)

	  ELSEIF ((INDEX('6',PDO.GRINDING_PARM) .GT. 0)  .AND.
	1         (INDEX('1AB23DC',COIL.CLASS_CODE) .GT. 0)) THEN
	    I = COIL.CURR_PROC_IDX
	    COIL.ACTL_PCODE(I+1:) = 'NWMP'// COIL.ACTL_PCODE(I+1:)
	  ENDIF
	ENDIF

	I = COIL.CURR_PROC_IDX
	BCODE = COIL.ACTL_PCODE(I+1:)
	Z_IDX = 0
	Z_IDX = INDEX(BCODE,'Z')
	IF(Z_IDX .GT. 0) THEN
	  Z_CODE = BCODE(Z_IDX:)
	ELSE
	  Z_CODE = '$'
	ENDIF 

	IF ((INDEX('RFS',PDO.CLASS_CODE) .LE. 0) .AND. 
	1   (INDEX('123456',PDO.GRINDING_PARM) .LE. 0)) THEN
	  IF ((PDO.ACTUAL_WEIGHT .GE. 3500) .AND. (PDO.PLAY_CODE .EQ.'Y')) THEN
C     15.3  (1).
	     IF ((ORDB.APN_NO .EQ. 'NS01') .OR.
	1        (ORDB.APN_NO .EQ. 'GP01') .OR.
	1        (ORDB.APN_NO .EQ. 'TL01')) THEN
			ACTL_PCODE = COIL.ACTL_PCODE(1:I) //'S'//Z_CODE
	     ENDIF
C  	    (2).
	     IF (PDO.RUNNING_MODE_CAP(3:3) .EQ. '1') THEN
			IF ((ORDB.COIL_IN_DIAM .EQ. 508) .AND.
	1	   (PDO.ACTUAL_THICKNESS .LE. 2)) THEN			        
				ACTL_PCODE = COIL.ACTL_PCODE(1:I) //'T'//Z_CODE 
			ELSEIF ((ORDB.COIL_IN_DIAM .EQ. 508) .AND.	        	
	1	  	((PDO.ACTUAL_THICKNESS .GT. 2) .AND. (PDO.ACTUAL_THICKNESS .LE. 3))) THEN			
				ACTL_PCODE = COIL.ACTL_PCODE(1:I) //'Y'//Z_CODE 
			ENDIF
	     ELSEIF (PDO.RUNNING_MODE_CAP(3:3) .EQ. '0') THEN	
		 	ACTL_PCODE = COIL.ACTL_PCODE
	     ENDIF
		
CD	 15.4
	ELSEIF ((PDO.ACTUAL_WEIGHT .GE. 3500) .AND. (PDO.PLAY_CODE .EQ. 'N')) THEN
C	   通用於15.4(1~2)
	IF ((((L4ORD.LINE_MARKING .NE. 'NNNN') .AND. 
	1   (L4ORD.LINE_MARKING .NE. ' ')) 
	1  .AND. (PDO.COIL_NOTE .EQ. 'Y')) .OR.
	1   (((L4ORD.LINE_MARKING .EQ. 'NNNN') .OR. 
	1   (L4ORD.LINE_MARKING .EQ. ' ')) .AND. 
	1   ((PDO.ACTUAL_WEIGHT .GT. ORDB.UNIT_WEIGHT_MIN) 
	1   .AND. (PDO.ACTUAL_WEIGHT .LT. ORDB.UNIT_WEIGHT_MAX)))) THEN
CD	   15.4 (1).
	IF (ORDB.EDGING .EQ. 'M') THEN
C	15.4(1A)	
			IF ((INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1           	   (INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) THEN
				CCODE = 'RSTUY'
				CLEN = 5
C	15.4(1B)
			ELSEIF (INDEX('010',PDO.RUNNING_MODE_CAP(3:5))) THEN
					CCODE = 'TUY'
					CLEN = 3
C       15.4(1C)
			ELSEIF (((INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1           		(INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) .AND.
	1           		((PDO.ACTUAL_THICKNESS .GT. 2.0) .AND. 
	1	     		(PDO.ACTUAL_THICKNESS .LE. 3.0))) THEN
					CCODE = 'RSTU'
					CLEN = 4
C	    15.4(1D)	
			ELSEIF ((INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1        		(INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .AND.
	1	       		(PDO.ACTUAL_THICKNESS .LE. 2.0)) THEN	
					CCODE = 'RSYU'
					CLEN = 4 

C	    15.4(1E 20210806新增)
			ELSEIF (COIL.ACTL_PCODE(1:1) .EQ. 'D') THEN
				CCODE = 'STUY'
				CLEN = 4
		
			ELSE
					CLEN = 0
			ENDIF
		
		L = 1
		 DO WHILE (L .LE. CLEN)
		   DO M = I,20
		    N = INDEX(BCODE,CCODE(L:L))
		     IF (N .GT. 0) THEN
		       BCODE = BCODE(1:N-1) // BCODE(N+1:)
		     ENDIF
		  END DO
		 L = L + 1
		END DO	
	    ACTL_PCODE = COIL.ACTL_PCODE(1:I) // BCODE	
CD 	15-4 (2).
	ELSEIF (ORDB.EDGING .EQ. 'C') THEN
C	15-4(2A)
	    IF ((INDEX('111',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      		    (INDEX('101',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) THEN
				CCODE = 'RSTUY'
				CLEN = 5
C	15-4(2B)
	    ELSEIF ((INDEX('011',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('001',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) THEN
				CCODE = 'TUY'
				CLEN = 3
C	15-4(2C)
	    ELSEIF (((INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) .AND.
	1               ((PDO.ACTUAL_THICKNESS .GT. 2.0) .AND. 
	1		        (PDO.ACTUAL_THICKNESS .LE. 3.0))) THEN
	        CCODE = 'RSTU'
	        CLEN = 4
C   15-4(2D)
	    ELSEIF (((INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) .AND.
	1               (PDO.ACTUAL_THICKNESS .LE. 2.0)) THEN
	        CCODE = 'RSYU'
	        CLEN = 4
	    ELSE
		CLEN = 0
	    ENDIF
		   L = 1
		   DO WHILE (L .LE. CLEN)
		   	DO M = I,20
		  	 N = INDEX(BCODE,CCODE(L:L))
		  	 IF (N .GT. 0) THEN
		  	 	BCODE = BCODE(1:N-1) // BCODE(N+1:)
		  	 ENDIF
		  	END DO
		       L = L + 1
		    END DO
		ACTL_PCODE = COIL.ACTL_PCODE(1:I) // BCODE
	ENDIF

C	15-3
	ELSEIF ((((L4ORD.LINE_MARKING .NE. 'NNNN') .AND. 
	1   (L4ORD.LINE_MARKING .NE. ' ')) 
	1  .AND. (PDO.COIL_NOTE .EQ. 'Y')) .OR.
	1   (((L4ORD.LINE_MARKING .EQ. 'NNNN') .OR. 
	1   (L4ORD.LINE_MARKING .EQ. ' ')) .AND. 
	1   ((PDO.ACTUAL_WEIGHT .LT. ORDB.UNIT_WEIGHT_MIN) 
	1   .AND. (PDO.ACTUAL_WEIGHT .GT. ORDB.UNIT_WEIGHT_MAX)))) THEN

C	15-4(3A)
	   		IF (((INDEX('111',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      		    (INDEX('101',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      		    (INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      		    (INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) .AND.	   
	1      		    ((PDO.ACTUAL_THICKNESS .GT. 2.0) .AND. 
	1		     (PDO.ACTUAL_THICKNESS .LE. 3.0))) THEN
				CCODE = 'RSTU'
				CLEN = 4
C	15-4(3B)
	   		ELSEIF (((INDEX('111',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('101',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) .AND.	
	1      			(PDO.ACTUAL_THICKNESS .LE. 2.0)) THEN 	
				CCODE = 'RSYU'
				CLEN = 4
C	15-4(3C)
	   		ELSEIF ((INDEX('010',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('000',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('110',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0) .OR.
	1      			(INDEX('100',PDO.RUNNING_MODE_CAP(3:5)) .GT. 0)) THEN
	  			ACTL_PCODE = COIL.ACTL_PCODE
	    		ELSE
				CLEN = 0
			ENDIF
		   L = 1
		   DO WHILE (L .LE. CLEN)
		   	DO M = I,20
		  	 N = INDEX(BCODE,CCODE(L:L))
		  	 IF (N .GT. 0) THEN
		  	 	BCODE = BCODE(1:N-1) // BCODE(N+1:)
		  	 ENDIF
		  	END DO
		       L = L + 1
		    END DO
		ACTL_PCODE = COIL.ACTL_PCODE(1:I) // BCODE    
CD	15-4 (4).
			ELSEIF (
	1       		(L4ORD.LINE_MARKING .NE. 'NNNN') .AND.
	1       		(L4ORD.LINE_MARKING .NE. '') .AND.
	1        		((PDO.COIL_NOTE .EQ. 'N') .OR. (PDO.COIL_NOTE .EQ. 'X'))     
	1  					) THEN	
					ACTL_PCODE = COIL.ACTL_PCODE(1:I) //'S'//Z_CODE 	    
			ENDIF	!通用於15.4
CD	15-5			
	  ELSEIF(PDO.ACTUAL_WEIGHT < 3500) THEN	
		ACTL_PCODE = COIL.ACTL_PCODE(1:I) //'$'
		ACTL_PCODE(1:1) = PDO.SURFACE_CODE
	  ENDIF
	ENDIF

	IF (ACTL_PCODE .NE. '') THEN
	  COIL.ACTL_PCODE = ACTL_PCODE
	ENDIF
	

C ---13.鋼捲狀態---
	I = COIL.CURR_PROC_IDX
	IF ((COIL.ACTL_PCODE(I+1:I+1) .EQ. '$') .OR.
	1   (COIL.ACTL_PCODE(I+1:I+1) .EQ. ' ')) THEN
		IF (INDEX('69.70',PDO.QC_CODE) .GT. 0) THEN
			COIL.IC_CODE = '70'
		ELSE
			COIL.IC_CODE = '65'
		ENDIF
	ELSE
		IF (INDEX('69.70',PDO.QC_CODE) .GT. 0) THEN
			COIL.IC_CODE = '70'
		ELSE
			COIL.IC_CODE = '32'
		ENDIF
	ENDIF
C   ---14.計劃製程編號(訂單)---
C	不變
C   ---16.目前產線作業代碼---
C	COIL_MOVE執行
C   ---17.目前實際製程索引---
C	COIL_MOVE執行
C   ---18.計劃冶金編號---
C	不變
C   ---19.實際冶金編號---
C	不變
C   ---20.上製程產線---
C	COIL_MOVE執行
C   ---21.本製程產線---
C	COIL_MOVE執行
C   ---22.下製程產線---
C	COIL_MOVE執行
C   ---23.本站之軋延周---
C	COIL_MOVE執行
	COIL.R_WEEK = ' '  
C	---24.上製程產出日期----
CD	若PDO傳出時間=240000則將其改成下一日的000000
CD	example , 20201015 24:00:00 -> 20201016 00:00:00
	IF (PDO.FINISH_TIME .EQ. '240000') THEN
	   PDO.FINISH_TIME = '000000'
	   I = 1
	ELSE
	   I = 0
	ENDIF
	VMS_DATE = PDO.FINISH_DATE//PDO.FINISH_TIME
	
	STATUS = GR_C8DATE_TO_BIN ( VMS_DATE , %REF(COIL.VMS_DATE) )
	IF (.NOT. STATUS) THEN
	   CALL DH_NOTICE('產出時間格式錯誤')
	   RETURN
	ENDIF
	IF (I .EQ. 1) THEN
	   CALL GR_ADD_DAY ( %REF(COIL.VMS_DATE) , 1.0 , %REF(COIL.VMS_DATE) )
	ENDIF
C 	25.合併鋼捲數量
	COIL.NO_OF_COILS = 1
C   ---26.預定分切之製程站別---
	COIL.CUT_STATION= ' '
C	27~37  照母鋼捲或兄弟鋼捲 (DEFECT_CODE1~5 在QC判斷時會從WIPB040H存入PDO，所以直接撈取PDO即可)
C   ---38.檢驗後出料品質碼---
	COIL.APN_CODE = PDO.SURFACE_CODE
C   ---39.切邊碼--- 在QC判斷時會從WIPB040H存入PDO，所以直接撈取PDO即可
C   ---40.託工編號---
	COIL.OEM_NO = ' '
C	---41.線上標記碼---
	IF (PDO.COIL_NOTE .EQ. 'Y') THEN
	  IF (L4ORD.LINE_MARKING .GT. ' ') then
	     COIL.LINE_MARKING = L4ORD.LINE_MARKING
	  ELSEIF (L4ORD.LINE_MARKING .EQ. ' ') THEN
	     COIL.LINE_MARKING = 'KKKK'
	  ENDIF
	ELSEIF (PDO.COIL_NOTE .EQ. 'X') THEN
	  COIL.LINE_MARKING = 'XXXX'
	ELSE 
	  COIL.LINE_MARKING = COIL.LINE_MARKING
	ENDIF
	
C   ---42.套筒類別---
	IF (PDO.EXIT_SLEEVE_THICKNESS .GT. 0) THEN
		WRITE (COIL.SLEEVE_KIND,FMT='(I2)')
	1	PDO.EXIT_SLEEVE_THICKNESS
	ELSE
		COIL.SLEEVE_KIND = ' '
	ENDIF
C	---43.襯紙類別---
	COIL.PAPER_CODE = PDO.PAPER_CODE     
C   ---44.母鋼捲號碼---
	COIL.MOTHER_COIL_NO = PDO.MOTHER_COIL_NO
C	---45.上製程排程編號---
	COIL.PREV_SCHD_NO = PDO.SCHD_NO
C   46.作業狀態碼	
	COIL.OPER_CODE = '52'
C   ---47.急單碼---
	COIL.RUSH_ORDER = ' '
C   ---48.鋼捲應用碼---
	COIL.COIL_APPLY = ' '
C   ---49.煉鋼頭尾塊--- 不變
C   ---50.鋼捲長度--
	IF (PDO.ACTUAL_LENGTH .GT. 0) THEN
		COIL.COIL_LENGTH = PDO.ACTUAL_LENGTH
	ENDIF 
C	---51.產品代碼---
	COIL.PRODUCT_CODE = COIL.ACTL_PCODE(1:1)
C   ---52.品保備註--
	COIL.QC_COMMENT = PDO.QC_COMMENT    
C       ---53.廠區--
C	COIL.FACTORY = 'A'
C       ---54.冷軋機軋下率--  沿用母鋼捲或兄弟
C       ---55.用途限定碼--
	DH_ITEM_LIST.STATUS = CPS_RESTRICT_APN
	1               (
	1                'CAP',
	1                PDO.COIL_NO,
	1                PDO.SCHD_NO,
	1                RESTRICT_APN
	1               )
	IF ((DH_ITEM_LIST.STATUS .NE. 0) .AND.
	1   (RESTRICT_APN .NE. ' ')) THEN
             COIL.RESTRICT_APN = RESTRICT_APN
	ENDIF
C       ---56~ 59系統日期時間--
C       ---60.預估繳庫日期--
        COIL.FORECAST_DATE = ' '
 
	OPEN   (
	1     UNIT=550,
	1     FILE='CPS$LOG:PCM_LENGTH.LOG',
	1     STATUS = 'UNKNOWN',
	1     ACCESS = 'APPEND',
	1     CARRIAGECONTROL='LIST',
	1     SHARED
	1     )
	WRITE (550,*) 'CAP:DH$_PDO_TO_COIL : ',COIL.COIL_NO,
	1	' ', COIL.VMS_DATE, 'LENGTH: ', COIL.COIL_LENGTH





C	將SHIFT_DATE由8碼轉為7碼
	CALL GR_C8_TO_C7DATE(PDO.SHIFT_DATE,S_DATE)


	DH_ITEM_LIST.STATUS = COIL_MOVE 
	1		(
	1		COIL.COIL_ID,
	1		%REF(COIL.COIL_WIDTH),
	1		%REF(COIL.COIL_THICK),
	1		%REF(COIL.COIL_WT),
	1		%REF(COIL.INNER_DIAM),
	1		%REF(COIL.OUTER_DIAM),
	1		%REF(COIL.STORAGE),
	1		%REF(COIL.VMS_DATE),
	1		%REF(COIL.CLASS_CODE),
	1		%REF(COIL.IC_CODE),
	1		%REF(PDO.DEFECT_CODE1),
	1		%REF(PDO.DEFECT_CODE2),
	1		%REF(PDO.DEFECT_CODE3),
	1		%REF(PDO.DEFECT_CODE4),
	1		%REF(PDO.DEFECT_CODE5),
	1		%REF(COIL.ACTL_PCODE),
	1		'CAP',
	1		PDO.SCHD_NO,
	1		DIVIDE_YN,
	1		%REF(COIL.COIL_LENGTH),
	1		%REF(COIL.OEM_NO),
	1		%REF(S_DATE),
	1		%REF(COIL.MOTHER_COIL_NO),
	1		COIL.LINE_MARKING,
	1		%REF(COIL.OPER_CODE),
	1		%REF(COIL.EDGING),
	1		%REF(PDO.QC_LOCK),
	1       %REF(COIL.QC_COMMENT),
	1		COIL.TOTAL_REDUCTION,
	1       COIL.RESTRICT_APN, 
	1		COIL.SLEEVE_KIND,
	1		COIL.PAPER_CODE
	1		)
	IF (.NOT. BTEST(DH_ITEM_LIST.STATUS,0) ) THEN
	   CALL DH_NOTICE ('鋼捲資料檔未更新')
	ENDIF


	IF (BTEST(DH_ITEM_LIST.STATUS,1) ) THEN
	   PDO.TRANSFER = 'Y'
	   CALL CAP_PDO_U ( PDO )
	   DH_ITEM_LIST.ADDR_TAB.DATA_BUF = %LOC(PDO)

C          轉檔百年日期
	   CALL GR_C8_TO_C7DATE(PDO.START_DATE,PDO.START_DATE)
	   CALL GR_C8_TO_C7DATE(PDO.FINISH_DATE,PDO.FINISH_DATE)
	   CALL GR_C8_TO_C7DATE(PDO.SHIFT_DATE,PDO.SHIFT_DATE)

	   CALL DH_FORM_SEND()
	   CALL DH_INTERNAL_MSG('處理完畢',2)
	ELSE
	   CALL DH_NOTICE ('製程記錄檔未更新')
	ENDIF

9000	CONTINUE

	CALL LIB$FREE_VM ( SIZEOF(COIL) , COIL_PNT , )
	CALL LIB$FREE_VM ( SIZEOF(ORDB) , ORDB_PNT , )
C	CALL LIB$FREE_VM ( SIZEOF(PDI) , PDI_PNT , )

	RETURN
	END


